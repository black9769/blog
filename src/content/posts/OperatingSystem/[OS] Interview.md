---
title: "[OS] Pre-Interview"
published: 2024-07-03
description: ''
image: ''
tags: [CS, OS,Interview]
category: 'Network'
draft: false 
---
#### 페이징과 세그멘테이션의 차이점에 대해 설명하시오.
> ⭐ 모범답안
>   
> 페이징과 세그멘테이션는 메모리 관리를 위한 기술로, 가상 메모리를 사용한다는 공통점은 있지만,
> 몇가지 차이점을 갖고 있다.  
> 
> 첫번째로는 블록의 크기이다. 페이징은 블록의 크기를 동일하게 나누어 Frame이라는 단위를 활용한다. 하지만 세그먼트는
> 블록의 크기가 각각 다른 크기를 갖을 수 있다.
> 
> 블록의 단위가 변경됨에 따라 발생하는 단편화도 다른데 페이지에서는 메모리 내부에서 발생되는 내부 단편화가 발생하지만, 모든 Frame의 크기가
> 동일하기 때문이다. 하지만 반대로 세그먼트는 가변적 단위를 갖고 있어서 외부 단편화가 발생할 수 있다. 
>
> 페이징과 세그멘테이션은 사용되는 운영체제에서도 차이가 있다. 페이징은 페이징 교체 알고리즘에 최적화 되어있기 때문에 현재 OS에 최적화 되어있으며
> 세그멘테이션은 특정 장비를 위한 임베딩 시스템에서 더 유리하다. 그 이유는 프로그램의 코드와 데이터를 구분하여 메모리에 저장하여 관리하기 때문에 메모리
> 접근에 대해서 보호하고 최적화하것에 유리하기 때문이다.


#### 메모리 단편화의 문제와 이를 해결하는 방법에 대해 설명하시오.
> ⭐ 모범답안  
> 
> 단편화는 2가지로 나눌 수 있습니다. 외부 단편화, 내부 단편화로 나눌 수 있다. 외부단편화란 메모리 내에서 가용 공간의 총합은 충분하지만,
> 물리적으로 분산되엉 있어 필요한 크기의 연속된 블록을 할당 할 수 없는 경우를 이야기한다. 내부 단편화는 할당된 메모리 블록 내에서 실제로 사용되지 않는 공간이
> 발생하는 상태를 말한다. 메모리 블룩의 크기와 요청된 메모리 크기가 일치하지 않아 발생한다.  
> 
> 외부단편화는 Compaction을 활용하여 가용 블록의 연속적인 공간을 만들 수 있다. 하지만 메모리의 이동 비용이 커 성능에 이슈가 생긴다.
> 그래서 페이징과 세그먼테이션을 활용한다.
> 내부단편화는 블록(Frame)의 크기를 실제 요청과 가깝게 설정하여 낭비되는 메모리 값을 최소화할 수 있다.


#### 가상 메모리(Virtual Memory)의 개념과 장단점을 설명하시오.
> ⭐ 모범답안
>
> 컴퓨터 시스템에서 사용되는 주요한 메모리 관리 기술입니다. 이 기술은 실제 물리적인 RAM(Randam Access Memory)보다 큰 메모리 공간을 프로세스에 제공하는 것을 목적으로 합니다. 가상 메모리는 주로 운영 체제에서 지원하며, 메모리의 효율성과 사용자 경험을 향상시키는 데 기여합니다.
> 가상 주소 공간에서 각 물리 메모리와 매핑된다. Paging과 스와핑을 활용하여 구연이 되는데 페이징은 프로세스를 동일한 크기의 페이지로 나누어 메모리에 저장하고 로드하게 된다. 스와핑을 서브 메모리를 활용하여
> 다시 메모리로 올릴때 사용된다. 페이징 폴트는 프로세스가 요청한 메모리가 물리 메모리에 없을때 발생한다. 
> 
> 물리 메모리보다 더 크게 공간을 활용할 수 있고, 최대한 효율적으로 동작 할 수 있도록 합니다. 프로세스간 독립적인 메모리 공간을 할당하여 안전하게 실행됩니다.
> 단점으로는 페이지 폴트가 있는데 디스크에서 페이지를 가져오는데 시간이 걸릴 수있다. 가상 주소를 물리 주소를 매핌하는 과정에서도 추가적으로 오버헤드가 발생한다.

#### 컨텍스트 스위칭(Context Switching)의 비용과 이를 줄이기 위한 기법에 대해 설명하시오.
> ⭐ 모범답안  
> 
> 컨텍스트 스위칭은 프로세스가 교체되면서 전환하는 과정을 말한다. 이 과정에서 CPU가 다른 프로세스로 전환할때 Overhead가 발생하여 시스템 성능에
> 중요한 영향을 미친다.
> 
> 결론적으로, Overhead를 줄이기 위해서 자원을 공유하는 Muti-Threading을 활용할 수 있다.Thread는 스택영역을 제외한 나머지 영역을 공유한다.
> 그렇게 되면 Overhead를 줄일 수 있다. 또한, 효율적인 스케듈링 알고리즘을 활용하여 컨텍스트 스위칭 빈도수를 낮추는 것도 고려해볼 수 있다.
> 스케듈링 기법에는 선점형, 비선점형 기법이 있다. 선점형 기법에서는 프로세스가 한 프로세스를 마치기 전까지 접근 할 수 없는 상호배제원칙에 따라 움직인다.
> FIFO, SFJ, HRN 스케듈링을 활용한다. 혹은 비선점형 스케듈링인 라운드 로빈, SRJF, MLQ, MLFQ와 같은 스케듈링 기법을 활용하면 된다.

#### 세마포어와 모니터의 개념과 차이점에 대해 설명하시오.
> ⭐ 모범답안  
> 
> 세마포어는 상호배제와 프로세스간 동기화를 위한 기법으로 Critical Section에 진입하기 위한 방법을 Counting을 활용한다.
> 세마포어는 Lock/unLock이 아닌 정수형으로 동작을 하며 프로세스가 있을 경우에는 0이 되면 Waiting이 되고 양수가 되면 Signal을 보내 자원을 활용할 수
> 있도록 합니다.
> 
> 세마포어는 이진 세마포어, 카운팅 세마포어로 나눌 수 잇다. 이진 세마포어는 뮤텍스와 같이 동작한다.
> 
> 모니터는 추상화된 데이터와 그 데이터를 조작하는 프로시저들로 뮤텍스를 추상화했다. Java language에는 Synchronized 키워드를 활용하여 모니터를 선언할 수 있다.
> 추상화가 가장 큰차이로 고수준 언어에서 접근이 가능하다는 것이다.

#### 교착상태(Deadlock)의 조건과 해결 방법을 설명하시오.
> 교착상태는 프로세스간 서로 가진 자원을 기다리며 과정에서 무한대기에 빠지는 상태이다. 교착상태의 필요조건으로는
> 상호배제, 점유대기, 비선점, 환형대기가 있다. 이 4가지 조건이 모두 만족해야 교착상태가 발생한다.
> 상호배제는 하나의 하나씩이라는 의미이며 다른 프로세스가 한 프로세스가 점유하고 있는 프로세스를 빼았지 못한다.
> 점유 대기는 프로세스가 활용한 자원을 놓아주지 않고 다음 자원이 자신이게 올때까지 대기한다. 비선점은 프로세스가 exit될때까지 자원을 놓아주지 않는다.
> 환형대기는 점유대기, 비선점 조건이 만족해야 발생하는데 Process가 다음 Process가 필요로하는 자원을 갖고 있을때 나타난다.
> 
> 교착상태를 해결하기 위한 방법으로는 4가지 조건중 한가지만 해결하면 된다. 그래서 대부분 회피, 탐지, 예방을 활용하여 해결한다.
> 예방에는 은행원 알고리즘을 활용하여 잔여 자원에 따라서 자원을 점유할지 말지를 결정한다. 혹은 회피 기법으로 그냥 교착상태가 발생했을때 단말기 전체를 리부팅하여 모든 프로세스를 졸료시킨다ㅏ.
> 

