---
title: "[OS] DeadLock"
published: 2024-06-25
description: ''
image: ''
tags: [CS, OS, DeadLock]
category: 'Operating System'
draft: false 
---
# DeadLock(데드락)
## 개요
두개의 Process가 있고 2개의 자원이 있다고 가정해보자. A Process는 자원1을 사용하고 있다. 자원2를 사용하기 위해서는 Waitting이 걸렸다. B Process는 그와 반대이다. 자원2를 사용하고 있고 자원1을 사용하는 것에는 Waiting이 걸렸다.

사람이라면 뭐 통신을 해서라도 풀겠지만, PC는 알아서 끝나겠지 하면서 무기한 대기 상태에 들어간다. 그것을 우리는 교착상태, 다시말해 데드락이라고 부른다.

더 쉬운예시는 [위키백과](https://ko.wikipedia.org/wiki/%EA%B5%90%EC%B0%A9_%EC%83%81%ED%83%9C#:~:text=%EA%B5%90%EC%B0%A9%20%EC%83%81%ED%83%9C(%E8%86%A0%E7%9D%80%E7%8B%80%E6%85%8B)%20%EB%98%90%EB%8A%94,%EC%99%84%EB%A3%8C%EB%90%98%EC%A7%80%20%EB%AA%BB%ED%95%98%EB%8A%94%20%EC%83%81%ED%83%9C%EC%9D%B4%EB%8B%A4.)에 나와있다.

아주 긴사다리를 상상해봐라. 그리고 한명이 올라갔다가 내려올려고한다. 하지만 아래에서는 올라가려는 사람만 있다. 두 사람은 결국 자기가 향하는 방향에 있는 사람이 비켜줄때까지 하염없이 대기하고 있다는 것이다.

이 교착상태는 OS에서 Critical한 존재다.

---
![Alt text](./ProcessAsset/deadLock.jpg)
## DeadLock의 조건

우리가 교착상태를 이야기 할때는 총 4가지의 필요조건이 전부 만족해야 교착상태가 일어난다.
1. [상호배제](/blog/posts/operatingsystem/os-process-synchronization/)
2. 점유대기
3. 비선점
4. 순환대기

### 상호배제
Mutual Exclusion ,상호배제이다.. 해당 내용은 DeadLock 뿐만 아니라 Process Syn를 맞추기 위해 등장하기도 하지만, 현재는 DeadLock 관점에서 이해를 해보자.

상호배제를 한국말로 풀어보자면, **서로가 서로를 포함하지 않고 제외시켜놓음**을 의미한다. 그 말 뜻은 프로세스1이 프로세스2가 점유하고 있는 지원을 안 사용하고 싶다는 것이다.

이 위에 글만 보면 "배타적이면 좋은거 아냐?" 라는 생각이 들 수 있지만, 위의 사다리 예시를 보자. 위로 내려가려는 사람은 "내려가기 위한 자원"만을 원한다. "올라가기 위한 자원"을 원치 않는다. 반대로 올라가는 사람을 보자. "올라가기 위한 자원"만 원한다. "내려가기 위한 자원"은 거들떠 보지도 않는다.

상호배제가 교착상태가 일어나는 필요조건 중 하나인지 이해를 할 수 있다고 생각한다.

상호배제는 process의 Syn와도 매우 연관이 있다.

### 점유대기
Holde and Wait, 즉 손에 뭘 쥐고 대기한다는 것이다. Process가 Resource를 가진채로 다음 Resource를 할당 받을 때까지 기다린다.

PC에서 자원은 엄청나게 효율적으로 사용해야한다. 한번이라도 노는 자원이 생겨서는 안된다. 그렇기 때문에 바턴 마냥 자원을 넘겨줬다 받았다 하게된다.

생각해보자. A프로세스는 자원1을 쥐고 자원2를 필요로한다. B프로세스는 자원2를 쥐고 자원1을 필요로한다.

어떻게 해야할까? 교착상태를 해결하는 방법에 나온다.

### 비선점
Non Preemption, CPU 스케듈링의 비선점을 생각해보자. 선점형과 가장 큰 차이점은 무엇인가? 선점형은 우선순위라던지, 타임퀀텀과 같은 다양한 방법으로 CPU를 선점해두지만, 비선점은 한 프로세스가 끝날때까지 다음 프로세스는 무기한 대기상태(Convoy Effect)에 빠진다.

Resource를 선점하지 못하면 그 Resource를 받을때까지 무기한 대기해야하기 때문에 DeadLock에 필요조건이라고 생각할 수 있다.

### 순환대기
Circular wait, 순환대기는 점유대기, 비선점이 만족해야 성립하는 조건이다. 각 Process는 순환 구조를 가지며 순환 구조에서 다음 Process가 요구하는 자원을 갖고 있다.

다시 쉽게말해서, 자원의 요청이 꼬리에 꼬리를 무는 형태로 Circle구조로 되어있다는 것이다. 유명한 설명으로는 식사하는 철학자 문제가 있다.

> 🥕**식사하는 철학자 문제**
>
> 5명의 철학자가 하나의 원탁에 앉아서 식사를 한다. 각각의 철학자들 사이에는 포크가 하나씩 있다. 접시 안에 든 요리는 포크를 두개 사용하여 먹는 스파케티다. 그리고 각각의 철학자는 다른 철학자한테 말을 할수 없으며, 번걸아가며 각자 식사하거나 생각하는 것만 가능하다.  
> 즉, 식사를 하기 위해서는 왼쪽과 오른쪽의 인접한 철학자가 모두 식사를 하지 않고 있어야한다. 또한 식사를 마치고 나면, 왼손과 오른손에 든 포크를 다른 철학자가 쓸 수 있도록 내려놓아야한다. 어떤 철학자도 굶지않고 식사하는 방법을 찾아라.

문제를 뜯어보면, 철학자들은 아마 다음과 같이 행동할 것이다.
1. 먹을 대기 중
2. 왼쪽 포크가 사용이 가능하다면 일단 집어든다.
3. 오른쪽 포크가 사용이 가능하다면 일단 집어든다.
4. 양쪽 포크를 잡으면 일정 시간 만큼 식사를 한다.
5. 오른쪽 포크를 내려놓는다.
6. 왼쪽 포크를 내려놓는다.
7. 다시 먹을 대기중

저렇게하면 모든 철학자들은 식사를 할 수있을까?

철학자들은 왼쪽과 오른쪽 포크를 한번에 가져오는 것이 아니라 왼쪽 포크를 집고 오른쪽 포크를 집어든다. 모든 왼쪽포크를 철학자가 든다면, 오른쪽에는 남아있는 포크가 없을 것이다. 이게 바로 DeadLock이 발생하는 것이다. 3번에 계속 머물러 있을것이다.

이렇게 4가지의 필요조건중 한가지만 만족하지 않더라도 DeadLock이 발생하지 않기 때문에 DeadLock을 방지하는 방법은 이 조건을을 예방하거나
회피, 무시, 발견 하는 방향으로 발전하게된다. 이와 관련해서 식사하는 철학자 문제도 해결해보자.

---
## DeadLock의 관리
### 예방
- 상호배제 조건의 제거
  - 자원이 항상 공유 될 수 있도록 설계
- 점유대기 조건의 제거
  - 자원을 요청할때 모든 자원을 한꺼번에(atomic)하게 요청
  - 점유하고 있는 동안 다른 자원 요청 불가
- 비선점 조건의 제거
  - Process가 다른 Process의 자원을 강제로 뺏을수 있도록 하용
- 환형대기 조건의 제거
  - 자원 유형에 순서를 매기며 순서에 맞춰서 자원을 요청

### 회피
- 은행원 알고리즘(Banker`s Algorithm)
  - 은행원 알고리즘은 은행에 자본금이 얼마나 있는지 확인 후 돈을 빌려주는것이라고 생각하면 된다. 안전하게 자원으 갖고 있을때 지원을 할당하도록 한다.
### 탐지 및 회복
DeadLock이 발생하는지 주기적으로 탐색하고 이를 해결한다.
- 자원 할당 그래프
  - 자원 할당 상황을 그래프로 표현하여 교착상태를 감지
- DeadLock 감지 알고리즘
  - 자원의 현재 상태를 분석하고 감지하여 감지되면 해당 Process를 종료하거나 자원을 선점시킨다.
### 무시
- 위에서 사용되는 알고리즘 대신에 그냥 무시해버린다. 자동으로 재부팅 시켜버린다.

---

## FINAL
교착상태에 대한 OS에서 매우 핵심적인 부분이며, 멀티 프로세스/스레드/프로그래밍에서 일어난다. 면접에서도 서술형 문제에서도
많이 물어본다. 알고있어야하는 필수 지식중 하나이다.
